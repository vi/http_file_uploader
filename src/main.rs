use std::ffi::OsStr;
use std::net::SocketAddr;
use std::process::exit;
use std::sync::atomic::AtomicBool;
use std::sync::Arc;
use std::task::{Context, Poll};
use std::time::Duration;
use std::{ffi::OsString, path::PathBuf};

use axum::extract::Multipart;
use axum::handler::Handler;
use axum::Extension;
use axum::{Router};
use hyper::StatusCode;
use tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt};
use tokio::process::Command;

use crate::flags::{CmdSink, CmdSinkProg};

mod flags {
    use std::path::Path;

    use super::*;
    xflags::xflags! {
        src "./src/main.rs"
        /// Special web server to allow shell scripts and other simple UNIX-ey programs to handle multipart/form-data HTTP  file uploads
        cmd HttpFileUploader {
            /// Bind and listen specified TCP socket
            optional -l,--listen addr : SocketAddr
            /// Optionally remove and bind this UNIX socket for listening incoming connections
            optional -u,--unix path: PathBuf
            /// Read from HTTP request from stdin and write HTTP response to stdout
            optional --inetd
            /// Expect file descriptor 0 (or specified) to be pre-bound listening TCP socket e.g. from systemd's socket activation
            /// You may want to specify `--fd 3` for systemd
            optional --accept-tcp
            /// Expect file descriptor 0 (or specified) to be pre-bound listening UNIX socket e.g. from systemd's socket activation
            /// You may want to specify `--fd 3` for systemd
            optional --accept-unix
            /// File descriptor to use for --inetd or --accept-... modes instead of 0.
            optional --fd fd: i32
            /// Serve only one successful upload, then exit.
            /// Failed child process executions are not considered as unsuccessful uploads for `--once` purposes, only invalid HTTP requests.
            /// E.g. trying to write to /dev/full does exit with --once, but failure to open --output file does not.
            optional --once
            /// Dump contents of the file being uploaded to stdout.
            optional -O,--stdout
            /// Save the file to specified location and overwrite it for each new upload (which may interleave)
            optional -o,--output path: PathBuf
            /// Execute specified program each time the upload starts, without CLI parameters by default and file content as in stdin
            /// On UNIX, SIGINT is sent to the process if upload is terminated prematurely
            optional -p,--program path: PathBuf
            /// Execute command line (after --) each time the upload starts. URL is not propagated. Uploaded file content is in stdin.
            /// On UNIX, SIGINT is sent to the process if upload is terminated prematurely
            optional -c,--cmdline
            /// Command line array for --cmdline option
            repeated argv: OsString
            /// Restrict multipart field to specified name instead of taking first encountred field.
            optional -n,--name field_name: String
            /// Require a file to be uploaded, otherwise failing the request.
            optional -r,--require-upload
            /// Pipe output of the executed program as a text/plain reply. HTTP status code gets independent from process exit code
            optional -P,--pipe
            /// Start this program in case when upload started, but failed to finish properly e.g. to remove the trimmed file
            optional --incomplete-upload-handler path: PathBuf
            /// Start this program after successful upload
            optional -A,--complete-upload-handler path: PathBuf
            /// Allow multiple uploads simultaneously
            optional -L,--parallelism
        }
    }
    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct HttpFileUploader {
        pub argv: Vec<OsString>,

        pub listen: Option<SocketAddr>,
        pub unix: Option<PathBuf>,
        pub inetd: bool,
        pub accept_tcp: bool,
        pub accept_unix: bool,
        pub fd: Option<i32>,
        pub once: bool,
        pub stdout: bool,
        pub output: Option<PathBuf>,
        pub program: Option<PathBuf>,
        pub cmdline: bool,
        pub name: Option<String>,
        pub require_upload: bool,
        pub pipe: bool,
        pub incomplete_upload_handler: Option<PathBuf>,
        pub complete_upload_handler: Option<PathBuf>,
        pub parallelism: bool,
    }

    impl HttpFileUploader {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end

    fn has_exactly_one_true(iter: impl IntoIterator<Item = bool>) -> bool {
        iter.into_iter().filter(|x| *x).count() == 1
    }

    pub enum CmdSinkProg<'a> {
        Program(&'a Path),
        Cmdline(&'a [OsString]),
    }

    pub enum CmdSink<'a> {
        Stdout,
        File(&'a Path),
        Prog(CmdSinkProg<'a>),
    }

    impl HttpFileUploader {
        pub fn validate_or_exit(&self) {
            if !has_exactly_one_true([
                self.listen.is_some() || self.unix.is_some(),
                self.inetd,
                self.accept_tcp,
                self.accept_unix
            ]) {
                eprintln!("Specify exactly one of --listen/--unix, --inetd or --accept");
                exit(1);
            }

            if !has_exactly_one_true([
                self.stdout,
                self.output.is_some(),
                self.program.is_some(),
                self.cmdline,
            ]) {
                eprintln!("Specify exactly one of --stdout, --output, --program or --cmdline");
                exit(1);
            }

            if self.fd.is_some() {
                if !self.inetd && !self.accept_tcp && !self.accept_unix {
                    eprintln!("--fd option is meaningless without --inetd or --accept");
                    exit(1);
                }
            }

            if self.cmdline {
                if self.argv.is_empty() {
                    eprintln!("Specify positional arguments to use --cmdline mode");
                    exit(1);
                }
            } else {
                if !self.argv.is_empty() {
                    eprintln!("No positional arguments expected unless --cmdline option is in use");
                    exit(1);
                }
            }

            if self.parallelism {
                if self.output.is_some() || self.stdout {
                    eprintln!("--output or --stdout is incompatible with --parallelism");
                    exit(1);
                }
                if self.once {
                    eprintln!("--output or --stdout is incompatible with --parallelism");
                    exit(1);
                }
            }
            if self.inetd && self.stdout && self.fd.is_none() {
                eprintln!("--inetd and --stdout are incompatible, unless --fd is also specified");
                exit(1);
            }

            if self.pipe {
                eprintln!("--pipe not implemented");
                exit(1);
            }
            if self.incomplete_upload_handler.is_some() {
                eprintln!("incomplete_upload_handler not implemented");
                exit(1);
            }
            if self.complete_upload_handler.is_some() {
                eprintln!("complete_upload_handler not implemented");
                exit(1);
            }
        }

        pub fn sink(&self) -> CmdSink<'_> {
            if self.stdout {
                return CmdSink::Stdout;
            }
            if let Some(ref path) = self.output {
                return CmdSink::File(path);
            }
            if let Some(ref path) = self.program {
                return CmdSink::Prog(CmdSinkProg::Program(path));
            }
            if self.cmdline {
                return CmdSink::Prog(CmdSinkProg::Cmdline(&self.argv));
            }
            unreachable!()
        }
    }
}


struct State {
    cmd: flags::HttpFileUploader,
    ban_new_requests: tokio::sync::Mutex<Arc<AtomicBool>>,
    shutdown_tx: std::sync::Mutex<Option<tokio::sync::oneshot::Sender<()>>>,
}

struct SendOnDrop(Option<tokio::sync::oneshot::Sender<()>>);
impl Drop for SendOnDrop {
    fn drop(&mut self) {
        if let Some(tx) = self.0.take() {
            let _ = tx.send(());
        }
    }
}
struct ResetOnDrop(Arc<AtomicBool>);
impl Drop for ResetOnDrop {
    fn drop(&mut self) {
        self.0.store(false, std::sync::atomic::Ordering::Relaxed);
    }
}

async fn handle_upload(
    state: Arc<State>,
    multipart: Option<Multipart>,
) -> eyre::Result<(StatusCode, String)> {
    let cmd = &state.cmd;
    let mut ban_new_requests_lock = None;
    let mut _unban_new_requests = None;
    if !cmd.parallelism {
        let lock = state.ban_new_requests.lock().await;
        if lock.load(std::sync::atomic::Ordering::Relaxed) {
            return Ok((
                StatusCode::TOO_MANY_REQUESTS,
                "Upload is already being served and --parallelism is not specified\n".to_owned(),
            ));
        }
        ban_new_requests_lock = Some(lock);
    }
    let sink = cmd.sink();

    let mut upload_happened = false;
    let mut _process_exiter : Option<SendOnDrop> = None;
    if let Some(mut multipart) = multipart {
        while let Some(mut field) = multipart.next_field().await? {
            let name = field.name();
            if let Some(ref require_name) = cmd.name {
                if name != Some(require_name) {
                    continue;
                }
            }

            macro_rules! official_start_of_the_upload {
                () => {
                    #[allow(unused_assignments)] {
                        upload_happened = true;
                    }
                    if let Some(ref lock) = ban_new_requests_lock {
                        lock.store(true, std::sync::atomic::Ordering::Relaxed);
                        if ! cmd.once {
                            _unban_new_requests = Some(ResetOnDrop(Arc::clone(lock)));
                        }
                    }
                    drop(ban_new_requests_lock);
                    if cmd.once {
                        _process_exiter = Some(SendOnDrop(state.shutdown_tx.lock().unwrap().take()));
                    }
                };
            }

            match sink {
                CmdSink::Stdout => {
                    let mut so = tokio::io::stdout();
                    official_start_of_the_upload!();

                    while let Some(mut chunk) = field.chunk().await? {
                        so.write_all_buf(&mut chunk).await?;
                    }
                    so.flush().await?;
                }
                CmdSink::File(path) => {
                    let mut f = tokio::fs::File::create(path).await?;
                    official_start_of_the_upload!();
                    while let Some(mut chunk) = field.chunk().await? {
                        f.write_all_buf(&mut chunk).await?;
                    }
                    f.flush().await?;

                }
                CmdSink::Prog(p) => {
                    let progname : &OsStr = match p {
                        CmdSinkProg::Program(p) => p.as_os_str(),
                        CmdSinkProg::Cmdline(argv) => &argv[0],
                    };
                    let mut command = Command::new(progname);
                    match p {
                        CmdSinkProg::Program(_) => {
                            // todo: supply URI as arg
                        }
                        CmdSinkProg::Cmdline(argv) => {
                            command.args(&argv[1..]);
                        }
                    }
                    command.stdin(std::process::Stdio::piped());
                    command.kill_on_drop(true);
                    let mut child = command.spawn()?;
                    let mut stdin = child.stdin.take().expect("Tokio process::Child's stdin is None despite of prior piped call");
                    official_start_of_the_upload!();
                    
                    while let Some(mut chunk) = field.chunk().await? {
                        stdin.write_all_buf(&mut chunk).await?;
                    }
                    stdin.shutdown().await?;
                    drop(stdin);

                    let code = child.wait().await?;
                    if code.success() {
                        return Ok((StatusCode::OK, "Upload successful\n".to_owned()))
                    } else {
                        return Ok((StatusCode::INTERNAL_SERVER_ERROR, format!("Process exited with code: {}\n",code)))
                    }
                }
            }

            break;
        }
    }
    if !upload_happened && cmd.require_upload {
        if let Some(ref require_name) = cmd.name {
            return Ok((
                StatusCode::BAD_REQUEST,
                format!("Multipart form field `{}` is not found\n", require_name),
            ));
        } else {
            return Ok((
                StatusCode::BAD_REQUEST,
                "No multipart form field found to upload\n".to_owned(),
            ));
        }
    }
    if upload_happened {
        Ok((StatusCode::OK, "Upload successful\n".to_owned()))
    } else {
        if cmd.program.is_some() || cmd.cmdline {
            Ok((
                StatusCode::OK,
                "No upload happened, but the program was executed\n".to_owned(),
            ))
        } else {
            Ok((
                StatusCode::BAD_REQUEST,
                "No upload happened and nothing occurred\n".to_owned(),
            ))
        }
    }
}

trait SocketLike: AsyncRead + AsyncWrite {}
impl<T: AsyncRead + AsyncWrite> SocketLike for T {}
type BoxedSocket = Box<dyn SocketLike + Send + Unpin>;

#[pin_project::pin_project]
struct CustomServer(#[pin] tokio::sync::mpsc::Receiver<BoxedSocket>);

impl hyper::server::accept::Accept for CustomServer {
    type Conn = BoxedSocket;

    type Error = eyre::Report;

    fn poll_accept(
        self: std::pin::Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Result<Self::Conn, Self::Error>>> {
        match self.project().0.poll_recv(cx) {
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Ready(Some(c)) => Poll::Ready(Some(Ok(c))),
            Poll::Pending => Poll::Pending,
        }
    }
}

async fn async_main(cmd: flags::HttpFileUploader) -> eyre::Result<()> {
    let (tx, rx) = tokio::sync::mpsc::channel::<BoxedSocket>(1);
    let (mut shutdown_tx, shutdown_rx) = tokio::sync::oneshot::channel::<()>();

    let mut tcp_listener = None;
    if let Some(la) = cmd.listen {
        tcp_listener = Some(tokio::net::TcpListener::bind(la).await?)
    }
    #[cfg(unix)]
    if cmd.accept_tcp {
        let fd = cmd.fd.unwrap_or(0);
        use std::os::unix::prelude::FromRawFd;
        let s = unsafe { std::net::TcpListener::from_raw_fd(fd) };
        s.set_nonblocking(true)?;
        tcp_listener = Some(tokio::net::TcpListener::from_std(s)?);
    }

    if let Some(s) = tcp_listener {
        let tx = tx.clone();
        tokio::spawn(async move {
            loop {
                match s.accept().await {
                    Ok((c, ca)) => {
                        eprintln!("Incoming connection from {}", ca);
                        let _ = tx.send(Box::new(c)).await;
                    }
                    Err(e) => {
                        eprintln!("Error accepting from TCP socket: {}", e);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                }
            }
        });
    }

    #[cfg(unix)]
    let mut unix_listener = None;
    #[cfg(unix)]
    if let Some(ref path) = cmd.unix {
        let _ = std::fs::remove_file(path);
        unix_listener = Some(tokio::net::UnixListener::bind(path)?);
    }
    #[cfg(unix)]
    if cmd.accept_unix {
        let fd = cmd.fd.unwrap_or(0);
        use std::os::unix::prelude::FromRawFd;
        let s = unsafe { std::os::unix::net::UnixListener::from_raw_fd(fd) };
        s.set_nonblocking(true)?;
        unix_listener = Some(tokio::net::UnixListener::from_std(s)?);
    }

    #[cfg(unix)]
    if let Some(s) = unix_listener {
        let tx = tx.clone();
        tokio::spawn(async move {
            loop {
                match s.accept().await {
                    Ok((c, _ca)) => {
                        eprintln!("Incoming connection from a UNIX socket");
                        let _ = tx.send(Box::new(c)).await;
                    }
                    Err(e) => {
                        eprintln!("Error accepting from UNIX socket: {}", e);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                }
            }
        });
    }

    macro_rules! plan_shutdown {
        () => {
            tokio::spawn(async move {
                // kludge to avoid premature exit or needless linger after the end of request
                // but can't just trigger `shutdown_tx` immediately, as it would cause server to quit before serving the request
                tokio::task::yield_now().await;
                tokio::time::sleep(Duration::from_millis(10)).await;
                let _ = shutdown_tx.send(());
            });
            let (fake_tx,_fake_rx) = tokio::sync::oneshot::channel();
            shutdown_tx = fake_tx;
        }
    }

    #[cfg(unix)]
    if cmd.inetd && cmd.fd.is_none() {
        let si = tokio::io::stdin();
        let so = tokio::io::stdout();
        let s = readwrite::ReadWriteTokio::new(si, so);
        tx.try_send(Box::new(s)).unwrap_or_else(|_|panic!("Expected guranteed send to a channel with nonzero buffer"));
        plan_shutdown!();
    }

    #[cfg(unix)]
    if let Some(fd) = cmd.fd {
        if cmd.inetd {
            use std::os::unix::prelude::FromRawFd;
            let s = unsafe { std::os::unix::net::UnixStream::from_raw_fd(fd) };
            s.set_nonblocking(true)?;
            let s = tokio::net::UnixStream::from_std(s)?;
            tx.try_send(Box::new(s)).unwrap_or_else(|_|panic!("Expected guranteed send to a channel with nonzero buffer"));
            plan_shutdown!();
        }
    }

    #[axum_macros::debug_handler]
    async fn handle_upload2(
        Extension(state): Extension<Arc<State>>,
        multipart: Option<Multipart>,
    ) -> (StatusCode, String) {
        match handle_upload(state, multipart).await {
            Ok(x) => x,
            Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, format!("Error: {:#}\n", e)),
        }
    }

    let state = Arc::new(State {
        cmd,
        ban_new_requests: tokio::sync::Mutex::new(Arc::new(AtomicBool::new(false))),
        shutdown_tx : std::sync::Mutex::new(Some(shutdown_tx)),
    });
    let app = Router::new()
        .fallback(handle_upload2.into_service())
        .layer(Extension(state));
    let makeservice = app.into_make_service();

    let incoming = CustomServer(rx);

    hyper::server::Builder::new(incoming, hyper::server::conn::Http::new())
        .serve(makeservice)
        .with_graceful_shutdown(async {
            shutdown_rx.await.ok();
        })
        .await?;
    Ok(())
}

fn main() -> eyre::Result<()> {
    let cmd = flags::HttpFileUploader::from_env_or_exit();
    cmd.validate_or_exit();

    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_io()
        .enable_time()
        .build()?;
    rt.block_on(async_main(cmd))?;

    Ok(())
}

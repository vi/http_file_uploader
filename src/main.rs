use std::ffi::OsStr;
use std::net::SocketAddr;
use std::path::Path;
use std::process::exit;
use std::sync::atomic::AtomicBool;
use std::sync::Arc;
use std::task::{Context, Poll};
use std::time::Duration;
use std::{ffi::OsString, path::PathBuf};

use axum::extract::Multipart;
use axum::extract::multipart::Field;
use axum::handler::Handler;
use axum::Extension;
use axum::{Router};
use hyper::StatusCode;
use tokio::io::{AsyncRead, AsyncWrite, AsyncWriteExt, AsyncReadExt};
use tokio::process::{Command, Child};

use crate::flags::{CmdSink, CmdSinkProg};

mod flags {
    use std::path::Path;

    use super::*;
    xflags::xflags! {
        src "./src/main.rs"
        /// Special web server to allow shell scripts and other simple UNIX-ey programs to handle multipart/form-data HTTP  file uploads
        cmd HttpFileUploader {
            /// Bind and listen specified TCP socket
            optional -l,--listen addr : SocketAddr
            /// Optionally remove and bind this UNIX socket for listening incoming connections
            optional -u,--unix path: PathBuf
            /// Read from HTTP request from stdin and write HTTP response to stdout
            optional --inetd
            /// Expect file descriptor 0 (or specified) to be pre-bound listening TCP socket e.g. from systemd's socket activation
            /// You may want to specify `--fd 3` for systemd
            optional --accept-tcp
            /// Expect file descriptor 0 (or specified) to be pre-bound listening UNIX socket e.g. from systemd's socket activation
            /// You may want to specify `--fd 3` for systemd
            optional --accept-unix
            /// File descriptor to use for --inetd or --accept-... modes instead of 0.
            optional --fd fd: i32
            /// Serve only one successful upload, then exit.
            /// Failed child process executions are not considered as unsuccessful uploads for `--once` purposes, only invalid HTTP requests.
            /// E.g. trying to write to /dev/full does exit with --once, but failure to open --output file does not.
            optional --once
            /// Dump contents of the file being uploaded to stdout.
            optional -O,--stdout
            /// Save the file to specified location and overwrite it for each new upload
            optional -o,--output path: PathBuf
            /// Execute specified program each time the upload starts, without CLI parameters by default and file content as in stdin
            /// On UNIX, SIGINT is sent to the process if upload is terminated prematurely
            optional -p,--program path: PathBuf
            /// Execute command line (after --) each time the upload starts. URL is not propagated. Uploaded file content is in stdin.
            /// On UNIX, SIGINT is sent to the process if upload is terminated prematurely
            optional -c,--cmdline
            /// Command line array for --cmdline option
            repeated argv: OsString
            /// Restrict multipart field to specified name instead of taking first encountred field.
            optional -n,--name field_name: String
            /// Require a file to be uploaded, otherwise failing the request.
            optional -r,--require-upload
            /// Allow multiple uploads simultaneously
            optional -L,--parallelism
            /// Buffer child process output to return it to HTTP client as text/plain
            optional -B,--bufer-stdout
            /// Pipe output of the executed program as a text/plain reply. HTTP status code gets independent from process exit code
            optional -P,--pipe
            /// Remove --output file if the upload was interrupted 
            optional --remove-incomplete
            /// Move --output's file to new path after the upload is fully completed
            optional --rename-complete path: PathBuf
        }
    }
    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct HttpFileUploader {
        pub argv: Vec<OsString>,

        pub listen: Option<SocketAddr>,
        pub unix: Option<PathBuf>,
        pub inetd: bool,
        pub accept_tcp: bool,
        pub accept_unix: bool,
        pub fd: Option<i32>,
        pub once: bool,
        pub stdout: bool,
        pub output: Option<PathBuf>,
        pub program: Option<PathBuf>,
        pub cmdline: bool,
        pub name: Option<String>,
        pub require_upload: bool,
        pub parallelism: bool,
        pub bufer_stdout: bool,
        pub pipe: bool,
        pub remove_incomplete: bool,
        pub rename_complete: Option<PathBuf>,
    }

    impl HttpFileUploader {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end

    fn has_exactly_one_true(iter: impl IntoIterator<Item = bool>) -> bool {
        iter.into_iter().filter(|x| *x).count() == 1
    }

    pub enum CmdSinkProg<'a> {
        Program(&'a Path),
        Cmdline(&'a [OsString]),
    }

    pub enum CmdSink<'a> {
        Stdout,
        File(&'a Path),
        Prog(CmdSinkProg<'a>),
    }

    impl HttpFileUploader {
        pub fn validate_or_exit(&self) {
            if !has_exactly_one_true([
                self.listen.is_some() || self.unix.is_some(),
                self.inetd,
                self.accept_tcp,
                self.accept_unix
            ]) {
                eprintln!("Specify exactly one of --listen/--unix, --inetd or --accept");
                exit(1);
            }

            if !has_exactly_one_true([
                self.stdout,
                self.output.is_some(),
                self.program.is_some(),
                self.cmdline,
            ]) {
                eprintln!("Specify exactly one of --stdout, --output, --program or --cmdline");
                exit(1);
            }

            if self.fd.is_some() {
                if !self.inetd && !self.accept_tcp && !self.accept_unix {
                    eprintln!("--fd option is meaningless without --inetd or --accept");
                    exit(1);
                }
            }

            if self.cmdline {
                if self.argv.is_empty() {
                    eprintln!("Specify positional arguments to use --cmdline mode");
                    exit(1);
                }
            } else {
                if !self.argv.is_empty() {
                    eprintln!("No positional arguments expected unless --cmdline option is in use");
                    exit(1);
                }
            }

            if self.parallelism {
                if self.output.is_some() || self.stdout {
                    eprintln!("--output or --stdout is incompatible with --parallelism");
                    exit(1);
                }
                if self.once {
                    eprintln!("--output or --stdout is incompatible with --parallelism");
                    exit(1);
                }
            }
            if self.inetd && self.stdout && self.fd.is_none() {
                eprintln!("--inetd and --stdout are incompatible, unless --fd is also specified");
                exit(1);
            }
            if (self.bufer_stdout || self.pipe) && self.program.is_none() && !self.cmdline {
                eprintln!("--buffer-stdout or --pipe only works with --program or --cmdline");
                exit(1);
            }
            if self.bufer_stdout && self.pipe {
                eprintln!("--buffer-stdout and --pipe cannot be used together");
                exit(1);
            }
            if self.remove_incomplete || self.rename_complete.is_some() {
                if self.output.is_none() {
                    eprintln!("--remove-incomplete or --rename-complete must be used with --output");
                    exit(1);
                }
            }

            if self.pipe {
                eprintln!("--pipe not implemented");
                exit(1);
            }
        }

        pub fn sink(&self) -> CmdSink<'_> {
            if self.stdout {
                return CmdSink::Stdout;
            }
            if let Some(ref path) = self.output {
                return CmdSink::File(path);
            }
            if let Some(ref path) = self.program {
                return CmdSink::Prog(CmdSinkProg::Program(path));
            }
            if self.cmdline {
                return CmdSink::Prog(CmdSinkProg::Cmdline(&self.argv));
            }
            unreachable!()
        }
    }
}


struct State {
    cmd: flags::HttpFileUploader,
    ban_new_requests: tokio::sync::Mutex<Arc<AtomicBool>>,
    shutdown_tx: std::sync::Mutex<Option<tokio::sync::oneshot::Sender<()>>>,
}

struct SendOnDrop(Option<tokio::sync::oneshot::Sender<()>>);
impl Drop for SendOnDrop {
    fn drop(&mut self) {
        if let Some(tx) = self.0.take() {
            let _ = tx.send(());
        }
    }
}
struct ResetOnDrop(Arc<AtomicBool>);
impl Drop for ResetOnDrop {
    fn drop(&mut self) {
        self.0.store(false, std::sync::atomic::Ordering::Relaxed);
    }
}

async fn handle_upload(
    state: Arc<State>,
    mut multipart: Option<Multipart>,
) -> eyre::Result<(StatusCode, String)> {
    let cmd = &state.cmd;
    let mut ban_new_requests_lock = None;
    let mut _unban_new_requests = None;
    if !cmd.parallelism {
        let lock = state.ban_new_requests.lock().await;
        if lock.load(std::sync::atomic::Ordering::Relaxed) {
            return Ok((
                StatusCode::TOO_MANY_REQUESTS,
                "Upload is already being served and --parallelism is not specified\n".to_owned(),
            ));
        }
        ban_new_requests_lock = Some(lock);
    }
    let sink = cmd.sink();

    let mut upload_happened = false;
    let mut _process_exiter : Option<SendOnDrop> = None;

    let chosen_field : Option<Field> = if let Some(ref mut multipart) = multipart {
        loop {
            match multipart.next_field().await? {
                None => break None,
                Some(field) => {
                    let name = field.name();
                    if let Some(ref require_name) = cmd.name {
                        if name != Some(require_name) {
                            continue;
                        }
                    }
                    break Some(field)
                }
            }
        }
    } else {
        None
    };

    macro_rules! official_start_of_the_upload {
        () => {
            #[allow(unused_assignments)] {
                upload_happened = true;
            }
            if let Some(ref lock) = ban_new_requests_lock {
                lock.store(true, std::sync::atomic::Ordering::Relaxed);
                if ! cmd.once {
                    _unban_new_requests = Some(ResetOnDrop(Arc::clone(lock)));
                }
            }
            drop(ban_new_requests_lock);
            if cmd.once {
                _process_exiter = Some(SendOnDrop(state.shutdown_tx.lock().unwrap().take()));
            }
        };
    }

    match sink {
        CmdSink::Stdout => {
            if let Some(mut field) = chosen_field {
                let mut so = tokio::io::stdout();
                official_start_of_the_upload!();

                while let Some(mut chunk) = field.chunk().await? {
                    so.write_all_buf(&mut chunk).await?;
                }
                so.flush().await?;
            }
        }
        CmdSink::File(path) => {
            if let Some(mut field) = chosen_field {
                let mut f = tokio::fs::File::create(path).await?;
                let mut remover : Option<RemoveOnDrop> = None;

                struct RemoveOnDrop<'a> { path : &'a Path, defused: bool}
                impl<'a> Drop for RemoveOnDrop<'a> {
                    fn drop(&mut self) {
                        if ! self.defused {
                            let _ = std::fs::remove_file(self.path);
                        }
                    }
                }

                if cmd.remove_incomplete {
                    remover = Some(RemoveOnDrop { path, defused: false })
                }

                official_start_of_the_upload!();
                while let Some(mut chunk) = field.chunk().await? {
                    f.write_all_buf(&mut chunk).await?;
                }
                f.flush().await?;
                drop(f);

                if let Some(mut rod) = remover {
                    rod.defused = true;
                }

                if let Some(ref newpath) = cmd.rename_complete {
                    tokio::fs::rename(path, newpath).await?;
                }

            }
        }
        CmdSink::Prog(p) => 'skip_prog: {
            if chosen_field.is_none() && cmd.require_upload {
                break 'skip_prog;
            }
            let progname : &OsStr = match p {
                CmdSinkProg::Program(p) => p.as_os_str(),
                CmdSinkProg::Cmdline(argv) => &argv[0],
            };
            let mut command = Command::new(progname);
            match p {
                CmdSinkProg::Program(_) => {
                    
                }
                CmdSinkProg::Cmdline(argv) => {
                    command.args(&argv[1..]);
                }
            }
            command.stdin(std::process::Stdio::piped());
            if cmd.bufer_stdout {
                command.stdout(std::process::Stdio::piped());
            }
            #[cfg(not(unix))]
            command.kill_on_drop(true);
            let child = command.spawn()?;

            struct ChildWrapper(Child);

            #[cfg(unix)]
            impl Drop for ChildWrapper {
                fn drop(&mut self) {
                    if let Some(id) = self.0.id() {
                        unsafe { libc::kill(id as libc::pid_t, libc::SIGINT); }
                    }
                }
            }

            let mut child = ChildWrapper(child);

            let mut stdin = child.0.stdin.take().expect("Tokio process::Child's stdin is None despite of prior piped call");
            official_start_of_the_upload!();

            let stdout_rx = if cmd.bufer_stdout {
                let (tx,rx) = tokio::sync::oneshot::channel();
                let mut stdout = child.0.stdout.take().expect("Tokio process::Child's stdout is None despite of prior piped call");
                tokio::spawn(async move {
                    let mut b = Vec::with_capacity(1024);
                    let _ = stdout.read_to_end(&mut b).await;
                    let _ = tx.send(b);
                });
                Some(rx)
            } else {
                None
            };

            if let Some(mut field) = chosen_field {
                while let Some(mut chunk) = field.chunk().await? {
                    stdin.write_all_buf(&mut chunk).await?;
                }
            }
            stdin.shutdown().await?;
            drop(stdin);

            // todo stdout

            let code = child.0.wait().await?;

            if let Some(stdout) = stdout_rx {
                let output = stdout.await.unwrap_or_default();
                // kludge to enable binary blobs over String
                // UB in theory, just transfers the buffer in practice, with wrong Content-Type though
                let output2 = unsafe { String::from_utf8_unchecked(output) };

                if code.success() {
                    return Ok((StatusCode::OK, output2))
                } else {
                    return Ok((StatusCode::INTERNAL_SERVER_ERROR, output2))
                }
            } else {
                if code.success() {
                    return Ok((StatusCode::OK, "Upload successful\n".to_owned()))
                } else {
                    return Ok((StatusCode::INTERNAL_SERVER_ERROR, format!("Process exited with code: {}\n",code)))
                }
            }
        }
    }

    if !upload_happened && cmd.require_upload {
        if let Some(ref require_name) = cmd.name {
            return Ok((
                StatusCode::BAD_REQUEST,
                format!("Multipart form field `{}` is not found\n", require_name),
            ));
        } else {
            return Ok((
                StatusCode::BAD_REQUEST,
                "No multipart form field found to upload\n".to_owned(),
            ));
        }
    }
    if upload_happened {
        Ok((StatusCode::OK, "Upload successful\n".to_owned()))
    } else {
        Ok((
            StatusCode::BAD_REQUEST,
            "No upload happened and nothing occurred\n".to_owned(),
        ))
    }
}

trait SocketLike: AsyncRead + AsyncWrite {}
impl<T: AsyncRead + AsyncWrite> SocketLike for T {}
type BoxedSocket = Box<dyn SocketLike + Send + Unpin>;

#[pin_project::pin_project]
struct CustomServer(#[pin] tokio::sync::mpsc::Receiver<BoxedSocket>);

impl hyper::server::accept::Accept for CustomServer {
    type Conn = BoxedSocket;

    type Error = eyre::Report;

    fn poll_accept(
        self: std::pin::Pin<&mut Self>,
        cx: &mut Context<'_>,
    ) -> Poll<Option<Result<Self::Conn, Self::Error>>> {
        match self.project().0.poll_recv(cx) {
            Poll::Ready(None) => Poll::Ready(None),
            Poll::Ready(Some(c)) => Poll::Ready(Some(Ok(c))),
            Poll::Pending => Poll::Pending,
        }
    }
}

async fn async_main(cmd: flags::HttpFileUploader) -> eyre::Result<()> {
    let (tx, rx) = tokio::sync::mpsc::channel::<BoxedSocket>(1);
    let (mut shutdown_tx, shutdown_rx) = tokio::sync::oneshot::channel::<()>();

    let mut tcp_listener = None;
    if let Some(la) = cmd.listen {
        tcp_listener = Some(tokio::net::TcpListener::bind(la).await?)
    }
    #[cfg(unix)]
    if cmd.accept_tcp {
        let fd = cmd.fd.unwrap_or(0);
        use std::os::unix::prelude::FromRawFd;
        let s = unsafe { std::net::TcpListener::from_raw_fd(fd) };
        s.set_nonblocking(true)?;
        tcp_listener = Some(tokio::net::TcpListener::from_std(s)?);
    }

    if let Some(s) = tcp_listener {
        let tx = tx.clone();
        tokio::spawn(async move {
            loop {
                match s.accept().await {
                    Ok((c, ca)) => {
                        eprintln!("Incoming connection from {}", ca);
                        let _ = tx.send(Box::new(c)).await;
                    }
                    Err(e) => {
                        eprintln!("Error accepting from TCP socket: {}", e);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                }
            }
        });
    }

    #[cfg(unix)]
    let mut unix_listener = None;
    #[cfg(unix)]
    if let Some(ref path) = cmd.unix {
        let _ = std::fs::remove_file(path);
        unix_listener = Some(tokio::net::UnixListener::bind(path)?);
    }
    #[cfg(unix)]
    if cmd.accept_unix {
        let fd = cmd.fd.unwrap_or(0);
        use std::os::unix::prelude::FromRawFd;
        let s = unsafe { std::os::unix::net::UnixListener::from_raw_fd(fd) };
        s.set_nonblocking(true)?;
        unix_listener = Some(tokio::net::UnixListener::from_std(s)?);
    }

    #[cfg(unix)]
    if let Some(s) = unix_listener {
        let tx = tx.clone();
        tokio::spawn(async move {
            loop {
                match s.accept().await {
                    Ok((c, _ca)) => {
                        eprintln!("Incoming connection from a UNIX socket");
                        let _ = tx.send(Box::new(c)).await;
                    }
                    Err(e) => {
                        eprintln!("Error accepting from UNIX socket: {}", e);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                }
            }
        });
    }

    macro_rules! plan_shutdown {
        () => {
            tokio::spawn(async move {
                // kludge to avoid premature exit or needless linger after the end of request
                // but can't just trigger `shutdown_tx` immediately, as it would cause server to quit before serving the request
                tokio::task::yield_now().await;
                tokio::time::sleep(Duration::from_millis(10)).await;
                let _ = shutdown_tx.send(());
            });
            let (fake_tx,_fake_rx) = tokio::sync::oneshot::channel();
            shutdown_tx = fake_tx;
        }
    }

    #[cfg(unix)]
    if cmd.inetd && cmd.fd.is_none() {
        let si = tokio::io::stdin();
        let so = tokio::io::stdout();
        let s = readwrite::ReadWriteTokio::new(si, so);
        tx.try_send(Box::new(s)).unwrap_or_else(|_|panic!("Expected guranteed send to a channel with nonzero buffer"));
        plan_shutdown!();
    }

    #[cfg(unix)]
    if let Some(fd) = cmd.fd {
        if cmd.inetd {
            use std::os::unix::prelude::FromRawFd;
            let s = unsafe { std::os::unix::net::UnixStream::from_raw_fd(fd) };
            s.set_nonblocking(true)?;
            let s = tokio::net::UnixStream::from_std(s)?;
            tx.try_send(Box::new(s)).unwrap_or_else(|_|panic!("Expected guranteed send to a channel with nonzero buffer"));
            plan_shutdown!();
        }
    }

    #[axum_macros::debug_handler]
    async fn handle_upload2(
        Extension(state): Extension<Arc<State>>,
        multipart: Option<Multipart>,
    ) -> (StatusCode, String) {
        match handle_upload(state, multipart).await {
            Ok(x) => x,
            Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, format!("Error: {:#}\n", e)),
        }
    }

    let state = Arc::new(State {
        cmd,
        ban_new_requests: tokio::sync::Mutex::new(Arc::new(AtomicBool::new(false))),
        shutdown_tx : std::sync::Mutex::new(Some(shutdown_tx)),
    });
    let app = Router::new()
        .fallback(handle_upload2.into_service())
        .layer(Extension(state));
    let makeservice = app.into_make_service();

    let incoming = CustomServer(rx);

    hyper::server::Builder::new(incoming, hyper::server::conn::Http::new())
        .serve(makeservice)
        .with_graceful_shutdown(async {
            shutdown_rx.await.ok();
        })
        .await?;
    Ok(())
}

fn main() -> eyre::Result<()> {
    let cmd = flags::HttpFileUploader::from_env_or_exit();
    cmd.validate_or_exit();

    let rt = tokio::runtime::Builder::new_current_thread()
        .enable_io()
        .enable_time()
        .build()?;
    rt.block_on(async_main(cmd))?;

    Ok(())
}
